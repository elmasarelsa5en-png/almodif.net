<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <title>إنشاء صوت إشعار طويل</title>
</head>
<body>
    <h1>إنشاء صوت إشعار طويل للتسجيلات الجديدة</h1>
    <button onclick="generateLongNotification()">توليد الصوت</button>
    <p id="status"></p>

    <script>
        async function generateLongNotification() {
            const statusEl = document.getElementById('status');
            statusEl.textContent = 'جاري الإنشاء...';

            try {
                // إنشاء Audio Context
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const sampleRate = audioContext.sampleRate;
                const duration = 3; // 3 ثواني - رنة طويلة
                const numChannels = 1;
                const frameCount = sampleRate * duration;

                // إنشاء AudioBuffer
                const audioBuffer = audioContext.createBuffer(numChannels, frameCount, sampleRate);
                const channelData = audioBuffer.getChannelData(0);

                // توليد صوت رنين متكرر (3 نغمات)
                for (let i = 0; i < frameCount; i++) {
                    const t = i / sampleRate;
                    
                    // نغمة 1: 800Hz (0-0.8 ثانية)
                    if (t < 0.8) {
                        channelData[i] = Math.sin(2 * Math.PI * 800 * t) * 0.3 * (1 - t/0.8);
                    }
                    // فاصل (0.8-1.0 ثانية)
                    else if (t < 1.0) {
                        channelData[i] = 0;
                    }
                    // نغمة 2: 1000Hz (1.0-1.8 ثانية)
                    else if (t < 1.8) {
                        const t2 = t - 1.0;
                        channelData[i] = Math.sin(2 * Math.PI * 1000 * t2) * 0.3 * (1 - t2/0.8);
                    }
                    // فاصل (1.8-2.0 ثانية)
                    else if (t < 2.0) {
                        channelData[i] = 0;
                    }
                    // نغمة 3: 1200Hz (2.0-3.0 ثانية)
                    else {
                        const t3 = t - 2.0;
                        channelData[i] = Math.sin(2 * Math.PI * 1200 * t3) * 0.4 * (1 - t3/1.0);
                    }
                }

                // تشغيل الصوت للاختبار
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                source.start();

                // تحويل إلى WAV
                const wavData = audioBufferToWav(audioBuffer);
                const blob = new Blob([wavData], { type: 'audio/wav' });
                
                // تنزيل الملف
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'long-notification.mp3';
                a.click();

                statusEl.textContent = 'تم! قم بحفظ الملف في public/sounds/';

            } catch (error) {
                statusEl.textContent = 'خطأ: ' + error.message;
                console.error(error);
            }
        }

        // تحويل AudioBuffer إلى WAV
        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;

            let result;
            if (numChannels === 2) {
                result = interleave(buffer.getChannelData(0), buffer.getChannelData(1));
            } else {
                result = buffer.getChannelData(0);
            }

            return encodeWAV(result, format, sampleRate, numChannels, bitDepth);
        }

        function encodeWAV(samples, format, sampleRate, numChannels, bitDepth) {
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;

            const buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
            const view = new DataView(buffer);

            /* RIFF identifier */
            writeString(view, 0, 'RIFF');
            /* file length */
            view.setUint32(4, 36 + samples.length * bytesPerSample, true);
            /* RIFF type */
            writeString(view, 8, 'WAVE');
            /* format chunk identifier */
            writeString(view, 12, 'fmt ');
            /* format chunk length */
            view.setUint32(16, 16, true);
            /* sample format (raw) */
            view.setUint16(20, format, true);
            /* channel count */
            view.setUint16(22, numChannels, true);
            /* sample rate */
            view.setUint32(24, sampleRate, true);
            /* byte rate (sample rate * block align) */
            view.setUint32(28, sampleRate * blockAlign, true);
            /* block align (channel count * bytes per sample) */
            view.setUint16(32, blockAlign, true);
            /* bits per sample */
            view.setUint16(34, bitDepth, true);
            /* data chunk identifier */
            writeString(view, 36, 'data');
            /* data chunk length */
            view.setUint32(40, samples.length * bytesPerSample, true);

            floatTo16BitPCM(view, 44, samples);

            return buffer;
        }

        function interleave(inputL, inputR) {
            const length = inputL.length + inputR.length;
            const result = new Float32Array(length);

            let index = 0;
            let inputIndex = 0;

            while (index < length) {
                result[index++] = inputL[inputIndex];
                result[index++] = inputR[inputIndex];
                inputIndex++;
            }
            return result;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function floatTo16BitPCM(output, offset, input) {
            for (let i = 0; i < input.length; i++, offset += 2) {
                const s = Math.max(-1, Math.min(1, input[i]));
                output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
        }
    </script>
</body>
</html>
